Individual Report Programming 2

This prototype was used for getting the user to experience vibration as feedback. At first, I only used one type of vibration for two different types of feedback. In one example of testing, the user asked if I could create a different vibration pattern for the different types of interaction with the prototype since it would be easier to understand. Here is where programming becomes highly resourceful, as you can play around with any different type of vibration pattern as supposed to use finished programs where there are limitations to what you can do. Me and the user tried a variation of different patterns til he was satisfied with one in particular which is used here. Basically, the interactive experience was dependent on my ability to create vibrations that the user asked for. Also, the first interaction with the prototype was the fact that I controlled the vibration via web sockets that created a sense of real life experience for the user. Being able to create a real life scenario without having the actually finished product Is partially thanks to the possibilities that programming offers. In this case, I can't find a reason for thinking that programming would be a burden, or cause a burden in this particularly design activity. I believe that I will always consider programming to be a resource in any type of design activity since it's not something that is randomly added. If you don't need to prototype ideas that involves programming, then you simply do not involve programming. It's something that you can fall back on, something to use to create different types of interactive experiences if users or creators needs it or demands it. It might sound simple enough to say that if you don't need it don't use it, but in this case I believe it to be true.
The only time programming would be a burden I believe, would be if it was forced upon a creator or a designer. I find it hard to imagine a scenario where that would happen but if it did, it could complicate a simple user test of a prototype and make it into something that it wasn't intended to be. I.e, getting the user tester more focused on the programming of a prototype instead of the real reason behind the testing of that prototype. The user might get distracted by lights, sounds or other interactive experiences when the designer wanted to test the feel of it, size, material and so forth.
 